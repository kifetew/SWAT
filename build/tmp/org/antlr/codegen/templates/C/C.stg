/*
 [The "BSD licence"]
 Copyright (c) 2005-2006 Terence Parr
 All rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions
 are met:
 1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.
 2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.
 3. The name of the author may not be used to endorse or promote products
    derived from this software without specific prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*
 * This code generating template was produced by Jim "Any relation to Eric?" Idle. 
 * If it does cause the destruction of the UniVerse, it will be pretty cool so long as 
 * I am in a different one at the time. 
 */
group C implements ANTLRCore ;

cTypeInitMap ::= [
	"int"		    : "0",              // Integers     start out being 0
	"long"		    : "0",              // Longs        start out being 0
	"float"		    : "0.0",            // Floats       start out being 0
	"double"	    : "0.0",            // Doubles      start out being 0
	"ANTLR3_BOOLEAN"    : "ANTLR3_FALSE",   // Booleans     start out being Antlr C for false
	"byte"		    : "0",              // Bytes        start out being 0
	"short"		    : "0",              // Shorts       start out being 0
	"char"		    : "0",              // Chars        start out being 0
	default		    : "NULL"            // Anything other than an atomic type (above) is a NULL (probably NULL pointer).
]

leadIn(type) ::=
<<
/** \file
 *  This <type> file was generated by $ANTLR version <ANTLRVersion>
 *
 *     -  From the grammar source file : <fileName>
 *     -                            On : <generatedTimestamp>
<if(LEXER)>
 *     -                 for the lexer : <name>Lexer
<endif>
<if(PARSER)>
 *     -                for the parser : <name>Parser
<endif>
<if(TREE_PARSER)>
 *     -           for the tree parser : <name>TreeParser
<endif>
 *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim "Any relation to Eric?" Idle - "jimi" at idledotws
 *
 * View this file with tabs set to 8 (:set ts=8 in gvim) and indent at 4 (:set sw=4 in gvim)
 *
>>

/** The overall file structure of a recognizer; stores methods for rules
 *  and cyclic DFAs plus support code.
 */
outputFile( LEXER,
            PARSER,
            TREE_PARSER,
            actionScope,
            actions,
            docComment, 
            recognizer,
            name, 
            tokens, 
            tokenNames, 
            rules,
            cyclicDFAs,
            bitsets,
            buildTemplate,
            profile,
            backtracking,
            synpreds,
            memoize,
            numRules,
            fileName,
            ANTLRVersion,
            generatedTimestamp,
            trace,
            scopes,
            superClass,
            literals
            ) ::=
<<
<leadIn("C source")>
*/
<if(actions.(actionScope).header)>

/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */
<actions.(actionScope).header>
/* End of Header action.
 * =============================================================================
 */
<endif>

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "<name>.h"

/* ----------------------------------------- */

<docComment>

<if(literals)>
/** String literals used by <name> that we must do things like matchs() with.
 *  C will normally just lay down 8 bit characters, and you can use L"xxx" to
 *  get wchar_t, but wchar_t is 16 bits on Windows, which is not UTF32 and so
 *  we perform this little trick of defining the literals as arrays of UINT32
 *  and passing in the address of these.
 */
<literals:{static ANTLR3_UCHAR	lit_<i>[]  = <it>;}; separator="\n">

<endif>

/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

<rules: {r |<if(r.ruleDescriptor.ruleScope)>
<ruleAttributeScopeFuncDecl(scope=r.ruleDescriptor.ruleScope)>
<ruleAttributeScopeFuncs(scope=r.ruleDescriptor.ruleScope)>
<endif>}>

<recognizer.scopes:{<if(it.isDynamicGlobalScope)>
<ruleAttributeScopeDef(scope=it)>
<globalAttributeScopeFuncDecl(scope=it)>
<globalAttributeScopeFuncs(scope=it)>
<endif>}>

/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */

<recognizer>

/* End of code
 * =============================================================================
 */

>>

headerFile( LEXER,
            PARSER,
            TREE_PARSER,
            actionScope, 
            actions,
            docComment, 
            recognizer,
            name, 
            tokens, 
            tokenNames, 
            rules,
            cyclicDFAs,
            bitsets,
            buildTemplate,
            profile,
            backtracking, 
            synpreds, 
            memoize, 
            numRules,
            fileName,
            ANTLRVersion,
            generatedTimestamp,
            scopes,
	    superClass,
            trace,
            literals
        ) ::=
<<
<leadIn("C header")>
<if(PARSER)>
 * The parser <mainName()>
<endif>
<if(LEXER)>
 * The lexer <mainName()>
<endif>
<if(TREE_PARSER)>
 * The tree parser <mainName()>
<endif>
has the callable functions (rules) shown below,
 * which will invoke the code for the associated rule in the source grammar
 * assuming that the input stream is pointing to a token/text stream that could begin
 * this rule.
 * 
 * For instance if you call the first (topmost) rule in a parser grammar, you will
 * get the results of a full parse, but calling a rule half way through the grammar will
 * allow you to pass part of a full token stream to the parser, such as for syntax checking
 * in editors and so on.
 *
 * The parser entry points are called indirectly (by function pointer to function) via
 * a parser context typedef p<name>, which is returned from a call to <name>New().
 *
<if(LEXER)>
 * As this is a generated lexer, it is unlikely you will call it 'manually'. However
 * the entry points are provided anyway.
 *
<endif>
 * The entry points for <name> are  as follows:
 *
 * <rules: {r |  - <headerReturnType(ruleDescriptor=r.ruleDescriptor,...)>      p<name>-><r.ruleDescriptor.name>(p<name>)}; separator="\n * ">
 *
 * The return type for any particular rule is of course determined by the source
 * grammar file.
 */
#ifndef	_<name>_H
#define _<name>_H
<actions.(actionScope).preincludes>
/* =============================================================================
 * Standard antlr3 C runtime definitions
 */
#include    \<antlr3.h>

/* End of standard antlr 3 runtime definitions
 * =============================================================================
 */
<actions.(actionScope).includes>
<actions.(actionScope).header>

#ifdef	WIN32
// Disable: Unreferenced parameter,                - Rules with parameters that are not used
//          constant conditional,                  - ANTLR realizes that a prediction is always true (synpred usually)
//          initialized but unused variable        - tree rewrite vairables declared but not needed
//          potentially unitialized variable used  - retval always returned from a rule 
//
// These are only really displayed at waring level /W4 but that is the code ideal I am aiming at
// and the codegen must generate some of these warnings by necessity, apart from 4100, which is
// usually generated when a parser rule is given a parameter that it does not use. Mostly though
// this is a matter of orthogonality hence I disable that one.
//
#pragma warning( disable : 4100 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4189 )
#pragma warning( disable : 4701 )
#endif
<if(backtracking)>

/* ========================
 * BACKTRACKING IS ENABLED
 * ========================
 */
<endif>

<rules:{r |<headerReturnScope(ruleDescriptor=r.ruleDescriptor,...)>}>

<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScopeDecl(scope=it)><endif>}>
<rules:{r |<ruleAttributeScopeDecl(scope=r.ruleDescriptor.ruleScope)>}>
<rules:{r |<ruleAttributeScopeFuncMacro(scope=r.ruleDescriptor.ruleScope)>}>

/** Context tracking structure for <mainName()>
 */
typedef struct <name>_Ctx_struct
{
    /** Built in ANTLR3 context tracker contains all the generic elements
     *  required for context tracking.
     */
<if(PARSER)>
    pANTLR3_PARSER   pParser;
<endif>
<if(LEXER)>
    pANTLR3_LEXER    pLexer;
<endif>
<if(TREE_PARSER)>
    pANTLR3_TREE_PARSER	    pTreeParser;
<endif>
<scopes:{<if(it.isDynamicGlobalScope)>
    <globalAttributeScopeDef(scope=it)>
<endif>}; separator="\n\n">
<rules: {r |<if(r.ruleDescriptor.ruleScope)>
    <ruleAttributeScopeDef(scope=r.ruleDescriptor.ruleScope)>
<endif>}>

<if(LEXER)>
    <rules:{r | <headerReturnType(ruleDescriptor=r.ruleDescriptor)> (*m<r.ruleDescriptor.name>)	(struct <name>_Ctx_struct * ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
<endif>
<if(PARSER)>
    <rules:{r | <headerReturnType(ruleDescriptor=r.ruleDescriptor)> (*<r.ruleDescriptor.name>)	(struct <name>_Ctx_struct * ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
<endif>
<if(TREE_PARSER)>
    <rules:{r | <headerReturnType(ruleDescriptor=r.ruleDescriptor)> (*<r.ruleDescriptor.name>)	(struct <name>_Ctx_struct * ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
<endif>
    unsigned char * (*getGrammarFileName)();
    void	    (*free)   (struct <name>_Ctx_struct * ctx);
    <@members>

    <@end>
}
    <name>, * p<name>;

<if(LEXER)>
/* Function protoypes for the lexer functions that external translation units
 * may wish to call.
 */
ANTLR3_API p<name> <name>New         (pANTLR3_INPUT_STREAM     instream);
<endif>
<if(PARSER)>
/* Function protoypes for the parser functions that external translation units
 * may wish to call.
 */
ANTLR3_API p<name> <name>New         (pANTLR3_COMMON_TOKEN_STREAM     instream);
<endif>
<if(TREE_PARSER)>
/* Function protoypes for the treeparser functions that external translation units
 * may wish to call.
 */
ANTLR3_API p<name> <name>New         (pANTLR3_COMMON_TREE_NODE_STREAM     instream);
<endif>
/** Symbolic definitions of all the tokens that the <grammarType()> will work with.
 * \{
 *
 * Antlr will define EOF, but we can't use that as it it is too common in
 * in C header files and that would be confusing. There is no way to filter this out at the moment
 * so we just undef it here for now. That isn't the value we get back from C recognizers
 * anyway. We are looking for ANTLR3_TOKEN_EOF.
 */
#ifdef	EOF
#undef	EOF
#endif
#ifdef	Tokens
#undef	Tokens
#endif 
<tokens:{#define <it.name>      <it.type>}; separator="\n">


/* End of token definitions for <name>
 * =============================================================================
 */
/** \} */

/* Work arounds because ruleScopeRef() does not have access to <name>
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   p<name>_##scope##_SCOPE
#define SCOPE_STACK(scope)  p<name>_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->p<name>_##scope##Top

/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always refering to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritence and without nailing anybody to a cross for 
 * suggesting we just be nice to each other.
 */
<if(LEXER)>
 
/* Macros for access things in a lexer
 */
#undef	    lexr
#undef	    rec		    
#undef	    ruleMemo		    
#undef	    getCharIndex
#undef	    getLine
#undef	    getCharPositionInLine
#undef	    emit
#undef	    emitNew
#undef	    matchc
#undef	    matchs
#undef	    matchRange
#undef	    ltoken
#undef	    hasFailed
#undef	    failedFlag
#undef	    theInput
#undef	    strStream
#undef	    LA
#undef	    hasException
#undef	    theException
#undef	    exConstruct
#undef	    inputConsume
#undef	    lrecover
#undef	    markMyWords
#undef	    rewindInput
#undef	    rewindLast
#undef	    backtracking

#define	    lexr		    ctx->pLexer
#define	    rec			    lexr->rec
#define	    ruleMemo		    rec->ruleMemo
#define	    getCharIndex()	    lexr->getCharIndex(lexr)
#define	    getLine()		    lexr->getLine(lexr)
#define	    getCharPositionInLine() lexr->getCharPositionInLine(lexr)
#define	    emit(t)		    lexr->emit(lexr, t)
#define	    emitNew(t,l,cp,ch,s,i)  lexr->emitNew(lexr, t, l, cp, ch, s, i)
#define	    matchc(c)		    lexr->matchc(lexr, c)
#define	    matchs(s)		    lexr->matchs(lexr, s)
#define	    matchRange(c1,c2)	    lexr->matchRange(lexr, c1, c2)
#define	    matchAny()		    rec->matchAny(rec)
#define	    ltoken()		    lexr->token
#define	    hasFailed()		    (rec->failed == ANTLR3_TRUE)
#define	    backtracking	    rec->backtracking
#define	    failedFlag		    rec->failed
#define	    theInput()		    lexr->input
#define	    strStream		    theInput()
#define	    LA(n)		    theInput()->istream->LA(lexr->input->istream, n)
#define	    EOF_TOKEN		    theInput()->istream->eofToken
#define	    hasException()	    (rec->error == ANTLR3_TRUE)
#define	    theException()	    rec->exception
#define	    exConstruct()	    rec->exConstruct(rec)
#define	    inputConsume()	    theInput()->istream->consume(theInput()->istream)
#define	    lrecover()		    lexr->recover(lexr)
#define	    markMyWords()	    theInput()->istream->mark(theInput()->istream)
#define	    rewindInput(m)	    theInput()->istream->rewind(theInput()->istream, m)
#define	    rewindLast()	    theInput()->istream->rewindLast(theInput()->istream)
<endif>

<if(PARSER)>
/* Macros for accessing things in the parser
 */
 
#undef	    prsr		    
#undef	    rec		    
#undef	    haveAlreadyParsedRule
#undef	    theInput
#undef	    strStream
#undef	    hasException
#undef	    theException
#undef	    tmatch
#undef	    tmatchAny
#undef	    followStk
#undef	    followPush
#undef	    followPop
#undef	    precover
#undef	    preportError
#undef	    LA
#undef	    LT
#undef	    exConstruct
#undef	    inputConsume
#undef	    markMyWords
#undef	    rewindInput
#undef	    rewindLast
#undef	    perrorRecovery
#undef	    hasFailed
#undef	    failedFlag
#undef	    precoverFromMismatchedSet
#undef	    precoverFromMismatchedElement

#define	    prsr		    ctx->pParser  
#define	    rec			    prsr->rec
#define	    haveAlreadyParsedRule(r) rec->alreadyParsedRule(rec, r)
#define	    theInput()		    prsr->tstream
#define	    strStream		    theInput()
#define	    hasException()	    (rec->error == ANTLR3_TRUE)
#define	    theException()	    rec->exception
#define	    tmatch(t, fs)	    rec->match(rec, t, fs)
#define	    tmatchAny()		    rec->matchAny(rec)
#define	    followStk()		    rec->following
#define	    followPush(x)	    followStk()->push(followStk(), ((void *)(x)), NULL)
#define	    followPop()		    followStk()->pop(followStk())
#define	    precover()		    rec->recover(rec)
#define	    preportError()	    rec->reportError(rec)
#define	    LA(n)		    theInput()->istream->LA(theInput()->istream, n)
#define	    LT(n)		    theInput()->LT(theInput(), n)
#define	    exConstruct()	    rec->exConstruct(rec)
#define	    inputConsume()	    theInput()->istream->consume(theInput()->istream)
#define	    markMyWords()	    theInput()->istream->mark(theInput()->istream)
#define	    rewindInput(m)	    theInput()->istream->rewind(theInput()->istream, m)
#define	    rewindLast()	    theInput()->istream->rewindLast(theInput()->istream)
#define	    perrorRecovery()	    rec->errorRecovery
#define	    _fsp		    rec->_fsp
#define	    failedFlag		    rec->failed
#define	    hasFailed()		    (failedFlag == ANTLR3_TRUE)
#define	    backtracking	    rec->backtracking
#define	    precoverFromMismatchedSet(s)	rec->recoverFromMismatchedSet(rec, s)
#define	    precoverFromMismatchedElement(e)	rec->recoverFromMismatchedElement(rec, s)
<endif>

<if(TREE_PARSER)>
/* Macros for accessing things in the parser
 */
 
#undef	    prsr
#undef	    rec		    
#undef	    haveAlreadyParsedRule
#undef	    theInput
#undef	    strStream
#undef	    hasException
#undef	    theException
#undef	    tmatch
#undef	    tmatchAny
#undef	    followStk
#undef	    followPush
#undef	    followPop
#undef	    precover
#undef	    preportError
#undef	    LA
#undef	    LT
#undef	    exConstruct
#undef	    inputConsume
#undef	    markMyWords
#undef	    rewindInput
#undef	    rewindLast
#undef	    perrorRecovery
#undef	    hasFailed
#undef	    failedFlag
#undef	    precoverFromMismatchedSet
#undef	    precoverFromMismatchedElement
#undef	    backtracking

#define	    prsr		    ctx->pTreeParser  
#define	    rec			    prsr->rec
#define	    haveAlreadyParsedRule(r) rec->alreadyParsedRule(rec, r)
#define	    theInput()		    prsr->ctnstream
#define	    strStream		    theInput()->tnstream
#define	    hasException()	    (rec->error == ANTLR3_TRUE)
#define	    theException()	    rec->exception
#define	    tmatch(t, fs)	    rec->match(rec, t, fs)
#define	    tmatchAny()		    rec->matchAny(rec)
#define	    followStk()		    rec->following
#define	    followPush(x)	    followStk()->push(followStk(), ((void *)(x)), NULL)
#define	    followPop()		    followStk()->pop(followStk())
#define	    precover()		    rec->recover(rec)
#define	    preportError()	    rec->reportError(rec)
#define	    LA(n)		    theInput()->tnstream->istream->LA(theInput()->tnstream->istream, n)
#define	    LT(n)		    theInput()->tnstream->LT(theInput()->tnstream, n)
#define	    exConstruct()	    rec->exConstruct(rec)
#define	    inputConsume()	    theInput()->tnstream->istream->consume(theInput()->tnstream->istream)
#define	    markMyWords()	    theInput()->tnstream->istream->mark(theInput()->tnstream->istream)
#define	    rewindInput(m)	    theInput()->tnstream->istream->rewind(theInput()->tnstream->istream, m)
#define	    rewindLast(m)	    theInput()->tnstream->istream->rewindLast(theInput()->tnstream->istream)
#define	    perrorRecovery()	    rec->errorRecovery
#define	    _fsp		    rec->_fsp
#define	    failedFlag		    rec->failed
#define	    hasFailed()		    (failedFlag == ANTLR3_TRUE)
#define	    backtracking	    rec->backtracking
#define	    precoverFromMismatchedSet(s)	rec->recoverFromMismatchedSet(rec, s)
#define	    precoverFromMismatchedElement(e)	rec->recoverFromMismatchedElement(rec, s)
<endif>

#endif

#ifndef	ANTLR3_TOKEN_STRUCT
#define ANTLR3_TOKEN_STRUCT
/** Work around because Token.UP and Token.DOWN are defined
 *  literally to dfaEdge() - consult with Ter on this one.
 */
typedef struct ANTLR3_TOKEN_STRUCT_struct
{
    ANTLR3_INT32   INVALID;
    ANTLR3_INT32   EOR;
    ANTLR3_INT32   DOWN;
    ANTLR3_INT32   UP;
}
    TOKEN_STRUCT;
    
#endif

/* END - Note:Keep extra linefeed to satisfy UNIX systems */

>>

grammarType() ::= <<
<if(PARSER)>
parser
<endif>
<if(LEXER)>
lexer
<endif>
<if(TREE_PARSER)>
tree parser
<endif>
>>

mainName() ::= <<
<if(PARSER)>
<name>
<endif>
<if(LEXER)>
<name>
<endif>
<if(TREE_PARSER)>
<name>
<endif>
>>

headerReturnScope(ruleDescriptor) ::= "<returnScope(...)>"

headerReturnType(ruleDescriptor) ::= "<returnType()>"

// Produce the lexer output
//
lexer(  grammar,
		name,
        tokens,
        scopes,
        rules, 
        numRules, 
        labelType="pANTLR3_COMMON_TOKEN",
        filterMode) ::= <<

<if(filterMode)>
/* Forward declare implementation function for ANTLR3_TOKEN_SOURCE interface.
 */
static pANTLR3_COMMON_TOKEN <name>NextToken   (pANTLR3_LEXER          lexerContext);
<endif>

/* Forward declare the locally static matching functions we have generated.
 */
<rules:{r | static <headerReturnType(ruleDescriptor=r.ruleDescriptor)>	m<r.ruleDescriptor.name>    (p<name> ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
static void	<name>Free(p<name> ctx);

<scopes:{<if(it.isDynamicGlobalScope)><globalAttributeScope(scope=it)><endif>}>

<actions.lexer.members>

static void
<name>Free  (p<name> ctx)
{
<if(memoize)>
    ruleMemo->free(ruleMemo);
<endif>
    lexr->free(lexr);
    
    ANTLR3_FREE(ctx);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "<fileName>";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}

<if(filterMode)>
    <filteringNextToken()>
<endif>

/** \brief Create a new lexer called <name>
 *
 * \param[in] instream Pointer to an initialized input stream
 *
 * \return 
 *     - Success p<name> initialized for the lex start
 *     - Fail (p<name>)(ANTLR3_ERR_NOMEM)
 */
ANTLR3_API p<name> <name>New         (pANTLR3_INPUT_STREAM     instream)
{
    p<name> lexCtx; /* Context structure we will build and return   */

    lexCtx = (p<name>) ANTLR3_MALLOC(sizeof(<name>));

    if  (lexCtx == NULL)
    {
        /* Failed to allocate memory for lexer context */
        return  (p<name>)ANTLR3_ERR_NOMEM;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * in base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 lexer function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in <name>.h here so you can get a sense
     * of what goes where.
     */
    
    /* Create a base lexer, using the supplied input stream
     */
    lexCtx->pLexer	= antlr3LexerNewStream(ANTLR3_SIZE_HINT, instream);

    /* Check that we allocated the memory correctly
     */
    if	(lexCtx->pLexer == (pANTLR3_LEXER)ANTLR3_ERR_NOMEM)
    {
	ANTLR3_FREE(lexCtx);
	return  (p<name>)ANTLR3_ERR_NOMEM;
    }
<if(memoize)>
    /* Create a LIST for recording rule memos.
     */
    lexCtx->pLexer->rec->ruleMemo    = antlr3ListNew(ANTLR3_SIZE_HINT);
<endif>

    /* Install the implementation of our <name> interface
     */
    <rules:{r | lexCtx->m<r.ruleDescriptor.name>	= m<r.ruleDescriptor.name>;}; separator="\n";>
    
    /** When the nextToken() call is made to this lexer's pANTLR3_TOKEN_SOURCE
     *  it will call mTokens() in this generated code, and will pass it the ctx
     * pointer of this lexer, not the context of the base lexer, so store that now.
     */
    lexCtx->pLexer->ctx	    = lexCtx;
    
    /** Install the token matching function
     */
    lexCtx->pLexer->mTokens = (void (*) (void *))(mTokens);
    
    lexCtx->getGrammarFileName	= getGrammarFileName;
    lexCtx->free		= <name>Free;
    
<if(filterMode)>
    /* We have filter mode turned on, so install the filtering nextToken function
     */
    lexCtx->lexer->tokSource->nextToken = <name>NextToken;
<endif>

    /* Return the newly built lexer to the caller
     */
    return  lexCtx;
}
<if(cyclicDFAs)>

/* =========================================================================
 * DFA tables for the lexer
 */
<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
/* =========================================================================
 * End of DFA tables for the lexer
 */
<endif> 

/* =========================================================================
 * Functions to match the lexer grammar defined tokens from the input stream
 */

<rules; separator="\n\n">

/* =========================================================================
 * Lexer matching rules end.
 * =========================================================================
 */
<if(synpreds)>

/* =========================================================================
 * Lexer syntactic predicates
 */
<synpreds:{p | <lexerSynpred(predname=p)>}>
/* =========================================================================
 * Lexer syntactic predicates end.
 * =========================================================================
 */
<endif>

/* End of Lexer code
 * ================================================
 * ================================================
 */ 

>>

/** An override of the lexer's nextToken() method that backtracks over mTokens() looking
 *  for matches.  No error can be generated upon error; just rewind, consume
 *  a token and then try again.  backtracking needs to be set as well.
 *  Make rule memoization happen only at levels above 1 as we start mTokens
 *  at backtracking==1.
 */
filteringNextToken() ::= <<
static ANTLR3_TOKEN 
<name>nextToken(p<name> lexCtx) 
{

    while (true) {
        if ( LA(1)==CharStream.EOF ) {
            return ANTLR_EOF_TOKEN;
        }
    ltoken  = NULL;
    tokenStartCharIndex = getCharIndex();
	text = NULL;
        try {
            int m = input.mark();
            backtracking=1; <! means we won't throw slow exception !>
            failed=false;
            mTokens();
            backtracking=0;
            <! mTokens backtracks with synpred at backtracking==2
               and we set the synpredgate to allow actions at level 1. !>
            if ( failed ) {
                input.rewind(m);
                input.consume(); <! advance one char and try again !>
            }
            else {
                return token;
            }
        }
        catch (RecognitionException re) {
            // shouldn't happen in backtracking mode, but...
            reportError(re);
            recover(re);
        }
    }
}

public void memoize(IntStream input,
		int ruleIndex,
		int ruleStartIndex)
{
if ( backtracking>1 ) super.memoize(input, ruleIndex, ruleStartIndex);
}

public boolean alreadyParsedRule(IntStream input, int ruleIndex) {
if ( backtracking>1 ) return super.alreadyParsedRule(input, ruleIndex);
return false;
}
>>

filteringActionGate() ::= "backtracking==1"

/** How to generate a parser */
genericParser(  grammar,
				name, 
                scopes, 
                tokens, 
                tokenNames, 
                rules, 
                numRules,
                bitsets,
                inputStreamType,
                superClass,
                ASTLabelType="pANTLR3_BASE_TREE",
                labelType,
				members
              ) ::= <<

/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
static pANTLR3_UINT8   <name>TokenNames[]
     = {
        (pANTLR3_UINT8) "\<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "\<EOR>",
        (pANTLR3_UINT8) "\<DOWN>", 
        (pANTLR3_UINT8) "\<UP>", 
        <tokenNames:{(pANTLR3_UINT8) <it>}; separator=",\n">
       };

/* Work around invalid dfaEdge() attribute passing
 * in tree parser
 */
 static TOKEN_STRUCT Token = {ANTLR3_TOKEN_INVALID, ANTLR3_EOR_TOKEN_TYPE, ANTLR3_TOKEN_DOWN, ANTLR3_TOKEN_UP };

    <@members>

    <@end>

/* Forward declare the locally static matching functions we have generated.
 */
<rules:{r | static <headerReturnType(ruleDescriptor=r.ruleDescriptor)>	<r.ruleDescriptor.name>    (p<name> ctx<if(r.ruleDescriptor.parameterScope)>, <endif><r.ruleDescriptor.parameterScope:parameterScope(scope=it)>);}; separator="\n";>
static void	<name>Free(p<name> ctx);

/* Function to initlize bitsets
 */
static	void <name>LoadFollowSets();

/* Function to destroy bitsets
 */
static	void <name>FreeFollowSets();

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the gramar file that generated this code
 */
static unsigned char fileName[] = "<fileName>";

/** \brief Return the name of the grammar file that generated this code.
 */
static unsigned char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new <name> parser and retrun a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API p<name>
<name>New   (<inputStreamType> instream)
{
    p<name> ctx;	    /* Context structure we will build and return   */
    
    ctx	= (p<name>) ANTLR3_MALLOC(sizeof(<name>));
    
    if	(ctx == NULL)
    {
	/* Failed to allocate memory for parser context */
        return  (p<name>)ANTLR3_ERR_NOMEM;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We intialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in <name>.h here, in order that you can get a sense
     * of what goes where.
     */

<if(PARSER)>
    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream);
<endif>
<if(TREE_PARSER)>
    /* Create a base Tree parser/recognizer, using the supplied tree node stream
     */
    ctx->pTreeParser		= antlr3TreeParserNewStream(ANTLR3_SIZE_HINT, instream);
<endif>

    /* Install the implementation of our <name> interface
     */
    <rules:{r | ctx-><r.ruleDescriptor.name>	= <r.ruleDescriptor.name>;}; separator="\n";>

    ctx->free			= <name>Free;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    <rules: {r |<if(r.ruleDescriptor.ruleScope)>
<ruleAttributeScope(scope=r.ruleDescriptor.ruleScope)><\n>
<endif>}>
    <recognizer.scopes:{<if(it.isDynamicGlobalScope)>
<globalAttributeScope(scope=it)><\n>
<endif>}>
    <@apifuncs>

    <@end>
    
    <actions.parser.apifuncs>
    <actions.treeparser.apifuncs>
	
    /* Install the token table
     */
    rec->tokenNames   = <name>TokenNames;
    
    /* Initialize the follow bit sets
     */
    <name>LoadFollowSets();
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 <name>Free(p<name> ctx)
 {
    /* Free any follow sets we created for error recovery
     */
    <name>FreeFollowSets();

    /* Free any scope memory
     */
    <rules: {r |<if(r.ruleDescriptor.ruleScope)>
<ruleAttributeScopeFree(scope=r.ruleDescriptor.ruleScope)><\n>
<endif>}>
    <recognizer.scopes:{<if(it.isDynamicGlobalScope)>
<globalAttributeScopeFree(scope=it)><\n>
<endif>}>
    
    <@cleanup>
    <@end>
<if(TREE_PARSER)>
    ctx->pTreeParser->free(ctx->pTreeParser);<\n>
<else>
    ctx->pParser->free(ctx->pParser);<\n>
<endif>
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this <grammarType()>
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return <name>TokenNames; 
}

    <members>
    
/* Declare the bitsets
 */
<bitsets:bitsetDeclare(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
                    words64=it.bits)>
     
/** Load up the static bitsets for following set for error recovery.
 *  \remark
 *  These are static after the parser is generated, hence they are static
 *  delcarations in the parser and are thread safe after initialization.
 */
static
void <name>LoadFollowSets()
{

    <bitsets:bitset(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>},
                    words64=it.bits)>
    return;
}

/** Free the bitsets used for error recovery and prediction.
 */
static
void	<name>FreeFollowSets()
{
    <bitsets:bitsetFree(name={FOLLOW_<it.name>_in_<it.inName><it.tokenIndex>})>

    return;
}
<if(cyclicDFAs)>

/* =========================================================================
 * DFA tables for the parser
 */
<cyclicDFAs:cyclicDFA()> <! dump tables for all DFA !>
/* =========================================================================
 * End of DFA tables for the parser
 */
<endif> 
 
/* ==============================================
 * Parsing rules
 */
<rules; separator="\n\n">
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
<synpreds:{p | <synpred(predname=p)>}>
/* End of syntactic predicates
 * ==============================================
 */

 
 


>>

parser(	grammar, 
		name, 
		scopes, 
		tokens, 
		tokenNames, 
		rules, 
		numRules,
		bitsets, 
		ASTLabelType, 
		superClass="Parser", 
		labelType="pANTLR3_COMMON_TOKEN", 
		members={<actions.parser.members>}
		) ::= <<
<genericParser(inputStreamType="pANTLR3_COMMON_TOKEN_STREAM", ...)>
>>

/** How to generate a tree parser; same as parser except the input
 *  stream is a different type.
 */
treeParser(	grammar, 
			name, 
			scopes, 
			tokens, 
			tokenNames, 
			globalAction, 
			rules, 
			numRules, 
			bitsets, 
			labelType={<ASTLabelType>}, 
			ASTLabelType="pANTLR3_BASE_TREE", 
			superClass="TreeParser", 
			members={<actions.treeparser.members>}
			) ::= <<
<genericParser(inputStreamType="pANTLR3_COMMON_TREE_NODE_STREAM", ...)>
>>

/** A simpler version of a rule template that is specific to the imaginary
 *  rules created for syntactic predicates.  As they never have return values
 *  nor parameters etc..., just give simplest possible method.  Don't do
 *  any of the normal memoization stuff in here either; it's a waste.
 *  As predicates cannot be inlined into the invoking rule, they need to
 *  be in a rule by themselves.
 */
synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) ::=
<<
// $ANTLR start <ruleName>
static void <ruleName>_fragment(p<name> ctx <ruleDescriptor.parameterScope:parameterScope(scope=it)>) 
{   
<if(trace)>
	printf("enter <ruleName> %d failed = %d, backtracking = %d\\n",input.LT(1),failed,backtracking);
        <block>
        printf("exit <ruleName> %d, failed = %d, backtracking = %d\\n",input.LT(1),failed,backtracking);
    
<else>
    <block>
<endif>
<ruleCleanUp()>
}
// $ANTLR end <ruleName>
/* End synpredRule(ruleName, ruleDescriptor, block, description, nakedBlock) */
>>

synpred(predname) ::= <<
static ANTLR3_BOOLEAN <predname>(p<name> ctx) 
{
    ANTLR3_UINT64   start;
    ANTLR3_BOOLEAN  success;

    backtracking++;
    <@start()>
    start	= markMyWords();
    <predname>_fragment(ctx);	    // can never throw exception
    success	= !(failedFlag);
    rewindInput(start);
    <@stop()>
    backtracking--;
    failedFlag	= ANTLR3_FALSE;
    return success;
}<\n>
>>

lexerSynpred(predname) ::= <<
<synpred(predname)>
>>

ruleMemoization(name) ::= <<
<if(memoize)>
if ( backtracking>0 && haveAlreadyParsedRule(<ruleDescriptor.index>) )
{
    return <ruleReturnValue()>; 
}
<endif>
>>

/** How to test for failure and return from rule */
checkRuleBacktrackFailure() ::= <<
<if(backtracking)>
/* checkRuleBacktrackFailure()
 */
if (hasFailed())
{
    return <ruleReturnValue()>;
}
<endif>
>>

/** This rule has failed, exit indicating failure during backtrack */
ruleBacktrackFailure() ::= <<
<if(backtracking)>
/* ruleBacktrackFailure()
 */
if (backtracking>0)
{
    failedFlag = <true()>; 
    return <ruleReturnValue()>;
}
<endif>
>>

/** How to generate code for a rule.  This includes any return type
 *  data aggregates required for multiple return values.
 */
rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions,memoize) ::= <<
/* rule(ruleName,ruleDescriptor,block,emptyRule,description,exceptions)
 * 
 * $ANTLR start <ruleName>
 * <fileName>:<description>
 */
static <returnType()>
<ruleName>(p<name> ctx<if(ruleDescriptor.parameterScope)>, <endif><ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{   
    <if(trace)>printf("enter <ruleName> %s failed=%d, backtracking=%d\n", LT(1), backtracking);<endif>
    <ruleDeclarations()>
    <ruleLabelDefs()>
    <ruleInitializations()>
    <ruleLabelInitializations()>
    <ruleDescriptor.actions.init>
    <@preamble()>
    <ruleMemoization(name=ruleName)>
    {
        <block>
    }
    
    <ruleCleanUp()>
<if(exceptions)>
    <exceptions:{e|<catch(decl=e.decl,action=e.action)><\n>}>
<else>
<if(!emptyRule)>
<if(actions.(actionScope).rulecatch)>
    <actions.(actionScope).rulecatch>
<else>
    if (hasException())
    {
        preportError();
        precover();
    }<\n>
<endif>
<endif>
<endif>
    <if(trace)>System.out.println("exit <ruleName> "+LT(1)+" failed="+failed+" backtracking="+backtracking);<endif>
    <ruleDescriptor.actions.finally:execAction()>
    <@postamble()>
    return <ruleReturnValue()>;
}
// $ANTLR end <ruleName>
>>

catch(decl,action) ::= <<
/* catch(decl,action)
 */
if  (hasException() && theException()->type == <e.decl> )
{
    <e.action>
}
>>

ruleDeclarations() ::= <<
/* ruleDeclarations()
 */
<if(ruleDescriptor.hasMultipleReturnValues)>
<returnType()> retval;
<else>
<ruleDescriptor.returnScope.attributes:{ a |
<a.type> <a.name> = <if(a.initValue)><a.initValue><else><initValue(a.type)><endif>;
}>
<endif>
<if(memoize)>
ANTLR3_UINT64 <ruleDescriptor.name>_StartIndex;
<endif>
>>

ruleInitializations() ::= <<
/* Initilalize rule variables
 */
<if(memoize)>
<ruleDescriptor.name>_StartIndex = theInput()->index(theInput());
<endif>
<ruleDescriptor.useScopes:{<scopeTop(sname=it.name)> = <scopePush(sname=it.name)>;}; separator="\n">
<ruleDescriptor.ruleScope:{<scopeTop(sname=it.name)> = <scopePush(sname=it.name)>;}; separator="\n">
/* End ruleDeclarations()
 */
>>

ruleLabelDefs() ::= <<
/* ruleLabelDefs()
 */
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels]
    :{<labelType>    <it.label.text>;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]
    :{pANTLR3_VECTOR    list_<it.label.text>;}; separator="\n"
>
<[ruleDescriptor.ruleLabels,ruleDescriptor.ruleListLabels]
    :ruleLabelDef(label=it); separator="\n"
>
<[ruleDescriptor.allRuleRefsInAltsWithRewrites,ruleDescriptor.allTokenRefsInAltsWithRewrites]
    :{pANTLR3_VECTOR     list_<it>;}; separator="\n"
>
>>

ruleLabelInitializations() ::= <<
/* ruleLabelInitializations()
 */
<[ruleDescriptor.tokenLabels,ruleDescriptor.tokenListLabels]
    :{<it.label.text>       = NULL;}; separator="\n"
>
<[ruleDescriptor.tokenListLabels,ruleDescriptor.ruleListLabels]
    :{list_<it.label.text>     = NULL;}; separator="\n"
>
<[ruleDescriptor.ruleLabels,ruleDescriptor.ruleListLabels]
    :ruleLabelInitVal(label=it); separator="\n"
>
<[ruleDescriptor.allRuleRefsInAltsWithRewrites,ruleDescriptor.allTokenRefsInAltsWithRewrites]
    :{list_<it>=ctx->vectors->newVector(ctx->vectors);}; separator="\n"
>
>>

ruleReturnValue() ::= <<
<if(!ruleDescriptor.isSynPred)>
<if(ruleDescriptor.hasReturnValue)>
<if(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnName>
<else>
retval
<endif>
<endif>
<endif>
>>

ruleCleanUp() ::= <<
/* ruleCleanUp()
 */
<if(memoize)>
<if(backtracking)>
if ( backtracking>0 ) { memoize(input, <ruleDescriptor.index>, <ruleDescriptor.name>_StartIndex); }
<endif>
<endif>
goto rule<ruleDescriptor.name>Ex; /* Prevent compiler warnings */
rule<ruleDescriptor.name>Ex: ;
<ruleDescriptor.useScopes:{<scopePop(sname=it)>;}; separator="\n">
<ruleDescriptor.ruleScope:{<scopePop(sname=it.name)>;}; separator="\n">
<if(ruleDescriptor.hasMultipleReturnValues)>
<endif>
>>

/** How to generate a rule in the lexer; naked blocks are used for
 *  fragment rules, which do not produce tokens.
 */
lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) ::= <<
/* lexerRule(ruleName,nakedBlock,ruleDescriptor,block,memoize) 
 */
/** \brief Lexer rule generated by ANTLR3
 *
 * $ANTLR start <ruleName>
 *
 * Looks to match the chracters the constitute the token <ruleName>
 * from the attached input stream.
 *
 * Comes from: <block.description>
 *
 * \remark
 *  - lexer->error == ANTLR3_TRUE if an exception was thrown.
 */
static
void m<ruleName>(p<name> ctx<if(ruleDescriptor.parameterScope)>, <endif><ruleDescriptor.parameterScope:parameterScope(scope=it)>)
{

    <if(trace)>System.out.println("enter <ruleName> '"+(char)LA(1)+"' line="+getLine()+":"+getCharPositionInLine()+" failed="+failed+" backtracking="+backtracking);<endif>
    <ruleDeclarations()>
    <ruleLabelDefs()>
    <ruleInitializations()>
    <ruleLabelInitializations()>
<if(nakedBlock)>
    ctx->pLexer->ruleNestingLevel++;
    <ruleDescriptor.actions.init>
    <ruleMemoization(name=ruleName)>
        
    <block><\n>
<else>
    ANTLR3_UINT32	    type;
    ANTLR3_UINT64	    start;
    ANTLR3_UINT64	    line;
    ANTLR3_UINT32	    charPosition;
    ANTLR3_UINT32	    channel;

    ctx->pLexer->ruleNestingLevel++;
    type	    = <ruleName>;
    start	    = getCharIndex();
    line	    = getLine();
    charPosition    = getCharPositionInLine();
    channel	    = ANTLR3_TOKEN_DEFAULT_CHANNEL;
        
    <ruleDescriptor.actions.init>
    <ruleMemoization(name=ruleName)>
    
    <block>
    <! create token if none exists *and* we are an outermost token rule !>
    <execAction({     
    if ( ltoken() == NULL && !hasException()) 
    {
		emitNew(type,line,charPosition,channel,start,getCharIndex()-1);
    }<\n>
    }
    )>
<endif>
    ctx->pLexer->ruleNestingLevel--;
    <if(trace)> -- Convert to C Jim!!! System.out.println("exit <ruleName> '"+(char)LA(1)+"' line="+getLine()+":"+getCharPositionInLine()+" failed="+failed+" backtracking="+backtracking);<endif>
    <ruleCleanUp()>
    <(ruleDescriptor.actions.finally):execAction()>

}
// $ANTLR end <ruleName>
>>

/** How to generate code for the implicitly-defined lexer grammar rule
 *  that chooses between lexer rules.
 */
tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor) ::= <<
/* tokensRule(ruleName,nakedBlock,args,block,ruleDescriptor)
 */
/** This is the entry point in to the lexer from an object that
 *  wants to generate the next token, such as a pCOMMON_TOKEN_STREAM
 */
static void 
mTokens(p<name> ctx)
{
    <block><\n>
    
    goto ruleTokensEx; /* Prevent compiler warnings */
ruleTokensEx: ;
}
>>

// S U B R U L E S

/** A (...) subrule with multiple alternatives */
block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<

/* block(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
 *
 * <fileName>:<description>
 */
{
    int alt<decisionNumber>=<maxAlt>;
    <decls>
    <@predecision()>
    <decision>
    <@postdecision()>
    <@prebranch()>
    switch (alt<decisionNumber>) 
    {
	<alts:altSwitchCase()>
    }
    <@postbranch()>
}
>>

/** A rule block with multiple alternatives */
ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
{
    /* ruleBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description)
    *
    * <fileName>:<description>
    */
    ANTLR3_UINT32 alt<decisionNumber>;

    alt<decisionNumber>=<maxAlt>;

    <decls>
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) 
    {
	<alts:altSwitchCase()>
    }
}
>>

ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
/* ruleBlockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description)
 * <fileName>:<description>
 */
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A special case of a (...) subrule with a single alternative */
blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) ::= <<
/* blockSingleAlt(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,description) 
 * <fileName>:<description>
 */
<decls>
<@prealt()>
<alts>
<@postalt()>
>>

/** A (..)+ block with 1 or more alternatives */
positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<
/* positiveClosureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
 * <fileName>:<description>
 */
{
    int cnt<decisionNumber>=0;
    <decls>
    <@preloop()>

    for (;;)
    {
        int alt<decisionNumber>=<maxAlt>;
	<@predecision()>
	<decision>
	<@postdecision()>
	switch (alt<decisionNumber>) 
	{
	    <alts:altSwitchCase()>
	    default:
	    
		if ( cnt<decisionNumber> >= 1 )
		{
		    goto loop<decisionNumber>; /* Ah well, generated code or I'd shoot myself */
		}
		<ruleBacktrackFailure()>
		<earlyExitEx()>
		<@earlyExitException()>
		goto rule<ruleDescriptor.name>Ex;
	}
	cnt<decisionNumber>++;
    }
    loop<decisionNumber>: ;	/* Jump to here if this rule does not match */
    <@postloop()>
}
>>

earlyExitEx() ::= <<
/* mismatchedSetEx()
 */
exConstruct();
theException()->type = ANTLR3_EARLY_EXIT_EXCEPTION;
theException()->name = ANTLR3_EARLY_EXIT_NAME;
<\n>
>>
positiveClosureBlockSingleAlt ::= positiveClosureBlock

/** A (..)* block with 1 or more alternatives */
closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) ::= <<

/* closureBlock(alts,decls,decision,enclosingBlockLevel,blockLevel,decisionNumber,maxK,maxAlt,description) 
 *
 * <fileName>:<description>
 */
<decls>

<@preloop()>
for (;;)
{
    int alt<decisionNumber>=<maxAlt>;
    <@predecision()>
    <decision>
    <@postdecision()>
    switch (alt<decisionNumber>) 
    {
	<alts:altSwitchCase()>
	default:
	    goto loop<decisionNumber>;	/* break out of the loop */
	    break;
    }
}
loop<decisionNumber>: ; /* Jump out to here if this rule does not match */
<@postloop()>
>>

closureBlockSingleAlt ::= closureBlock

/** Optional blocks (x)? are translated to (x|) by antlr before code generation
 *  so we can just use the normal block template
 */
optionalBlock ::= block

optionalBlockSingleAlt ::= block

/** A case in a switch that jumps to an alternative given the alternative
 *  number.  A DFA predicts the alternative and then a simple switch
 *  does the jump to the code that actually matches that alternative.
 */
altSwitchCase() ::= <<
/* altSwitchCase()
 */
case <i>:
    <@prealt()>
    <it>
    break;<\n>
>>

/** An alternative is just a list of elements; at outermost level */
alt(elements,altNum,description,autoAST,outerAlt) ::= <<
/* alt(elements,altNum,description,autoAST,outerAlt)
 * <fileName>:<description>
 */
{
    <@declarations()>
    <@initializations()>
    <elements:element()>
    <@cleanup()>
}
>>

// E L E M E N T S

/** Dump the elements one per line */
element() ::= <<
/* element()
 */
<@prematch()>
<it.el><\n>
>>

/** match a token optionally with a label in front */
tokenRef(token,label,elementIndex) ::= <<
/* tokenRef(token,label,elementIndex)
 */
<if(label)>
<label> = (<labelType>)LT(1);<\n>
<endif>
tmatch(<token>, FOLLOW_<token>_in_<ruleName><elementIndex>); 
<checkRuleBacktrackFailure()>
>>

/** ids+=ID */
tokenRefAndListLabel(token,label,elementIndex) ::= <<
/* tokenRefAndListLabel(token,label,elementIndex)
 */
<tokenRef(...)>
<listLabel(...)>
>>

listLabel(label) ::= <<
/* listLabel(label)
 */
if (list_<label> == NULL)
{
    list_<label>=ctx->vectors->newVector(ctx->vectors);
}
list_<label>->add(list_<label>, <label>, NULL);
>>


/** match a character */
charRef(char,label) ::= <<
/* charRef(char,label)
 */
<if(label)>
<label> = LA(1);<\n>
<endif>
matchc(<char>); 
<checkRuleBacktrackFailure()>
>>

/** match a character range */
charRangeRef(a,b) ::= <<
/* charRangeRef(a,b)
 */
matchRange(<a>, <b>); 
<checkRuleBacktrackFailure()>
>>

/** For now, sets are interval tests and must be tested inline */
matchSet(s,label,elementIndex,postmatchCode="") ::= <<
/* matchSet(s,label,elementIndex,postmatchCode="")
 */
<if(label)>
<label>=(<labelType>)LT(1);<\n>
<endif>
if ( <s> ) 
{
    <postmatchCode>
    inputConsume();
<if(!LEXER)>
    perrorRecovery()=ANTLR3_FALSE;
<endif>
    <if(backtracking)>failedFlag=ANTLR3_FALSE;<\n><endif>
}
else 
{
    <ruleBacktrackFailure()>
    <mismatchedSetEx()>
    <@mismatchedSetException()>
<if(LEXER)>
    lrecover();
<else>
    precoverFromMismatchedSet(FOLLOW_set_in_<ruleName><elementIndex>);
<endif>
    goto rule<ruleDescriptor.name>Ex;
}<\n>
>>

mismatchedSetEx() ::= <<
/* mismatchedSetEx()
 */
exConstruct();
theException()->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
theException()->name         = ANTLR3_MISMATCHED_SET_NAME;
<if(PARSER)>
theException()->expectingSet = FOLLOW_set_in_<ruleName><elementIndex>;
<endif>
>>

matchSetAndListLabel(s,label,elementIndex,postmatchCode) ::= <<
/* matchSetAndListLabel(s,label,elementIndex,postmatchCode)
 */
<matchSet(...)>
<listLabel(...)>
>>

/** Match a string literal */
lexerStringRef(string,label) ::= <<
/* lexerStringRef(string,label)
 */
<if(label)>
int <label>Start = getCharIndex();
matchs(<string>); 
<checkRuleBacktrackFailure()>
<labelType> <label> = lexr->tokFactory->newToken(lexr->tokFactory);
<label>->setType(<label>, ANTLR3_TOKEN_INVALID);
<label>->setStartIndex(<label>, <label>Start);
<label>->setStopIndex(<label>, getCharIndex()-1);
<label>->input = theInput()->tnstream->istream;
<else>
matchs(<string>); 
<checkRuleBacktrackFailure()><\n>
<endif>
>>

wildcard(label,elementIndex) ::= <<
/* wildcard(label,elementIndex)
 */
<if(label)>
<label>=(<labelType>)LT(1);<\n>
<endif>
tmatchAny(); 
<checkRuleBacktrackFailure()>
>>

wildcardAndListLabel(label,elementIndex) ::= <<
/* wildcardAndListLabel(label,elementIndex)
 */
<wildcard(...)>
<listLabel(...)>
>>

/** Match . wildcard in lexer */
wildcardChar(label, elementIndex) ::= <<
/* wildcardChar(label, elementIndex)
 */
<if(label)>
int <label> = LA(1);<\n>
<endif>
matchAny(); 
<checkRuleBacktrackFailure()>
>>

wildcardCharListLabel(label, elementIndex) ::= <<
/* wildcardCharListLabel(label, elementIndex)
 */
<wildcardChar(...)>
<listLabel(...)>
>>

/** Match a rule reference by invoking it possibly with arguments
 *  and a return value or values.
 */
ruleRef(rule,label,elementIndex,args) ::= <<
/* ruleRef(rule,label,elementIndex,args)
 */
followPush(FOLLOW_<rule>_in_<ruleName><elementIndex>);
<if(label)>
<label>=<rule>(ctx<if(args)>, <args; separator=", "><endif>);<\n>
<else>
<rule>(ctx<if(args)>, <args; separator=", "><endif>);<\n>
<endif>
if  (hasException())
{
    goto rule<ruleDescriptor.name>Ex;
}
_fsp--;
<checkRuleBacktrackFailure()>
>>

/** ids+=ID */
ruleRefAndListLabel(rule,label,elementIndex,args) ::= <<
/* ruleRefAndListLabel(rule,label,elementIndex,args)
 */
<ruleRef(...)>
<listLabel(...)>
>>

/** A lexer rule reference */
lexerRuleRef(rule,label,args) ::= <<
/* lexerRuleRef(rule,label,args)
 * From: <description>
 */
<if(label)>
{
    ANTLR3_UINT64 <label>Start = getCharIndex();
    m<rule>(ctx <if(args)>, <endif><args; separator=", ">); 
    <checkRuleBacktrackFailure()>
    <label> = lexr->tokFactory->newToken(lexr->tokFactory);
    <label>->setType(<label>, ANTLR3_TOKEN_INVALID);
    <label>->setStartIndex(<label>, <label>Start);
    <label>->setStopIndex(<label>, getCharIndex()-1);
    <label>->input = theInput();
}
<else>
m<rule>(ctx <if(args)>, <endif><args; separator=", ">); 
<checkRuleBacktrackFailure()>
<endif>
>>

/** EOF in the lexer */
lexerMatchEOF(label) ::= <<
/* lexerMatchEOF(label)
 */
<if(label)>
{
    int <label>Start = getCharIndex();
    <labelType> <label>;
    matchc(ANTLR3_CHARSTREAM_EOF); 
    <checkRuleBacktrackFailure()>
    <label> = lexr->tokFactory->newToken(lexr->tokFactory);
    <label>->setType(<label>, ANTLR3_TOKEN_EOF);
    <label>->setStartIndex(<label>, <label>Start);
    <label>->setStopIndex(<label>, getCharIndex()-1);
    <label>->input = theInput()->tnstream->istream;
}
<else>
    matchc(ANTLR3_CHARSTREAM_EOF); 
    <checkRuleBacktrackFailure()>
    <endif>
>>

/** match ^(root children) in tree parser */
tree(root, children, nullableChildList) ::= <<
/* tree(root, children)
 */
<root:element()>
<if(nullableChildList)>
if ( LA(1)==ANTLR3_TOKEN_DOWN ) {
    tmatch(ANTLR3_TOKEN_DOWN, NULL); 
    <checkRuleBacktrackFailure()>
    <children:element()>
    tmatch(ANTLR3_TOKEN_UP, NULL); 
    <checkRuleBacktrackFailure()>
}
<else>
tmatch(ANTLR3_TOKEN_DOWN, NULL); 
<checkRuleBacktrackFailure()>
<children:element()>
tmatch(ANTLR3_TOKEN_UP, NULL); 
<checkRuleBacktrackFailure()>
<endif>
>>

/** Every predicate is used as a validating predicate (even when it is
 *  also hoisted into a prediction expression).
 */
validateSemanticPredicate(pred,description) ::= <<
/* validateSemanticPredicate(pred,description) 
 */
if ( !(<evalPredicate(...)>) ) 
{
    <ruleBacktrackFailure()>
    <newFPE(...)>
}
>>

newFPE() ::= <<
    /* newFPE()
     */
    exConstruct();
    theException()->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
    theException()->message      = "<description>";
    theException()->ruleName	 = "<ruleName>";
    <\n>
>>

// F i x e d  D F A  (if-then-else)

dfaState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<

/* dfaState(k,edges,eotPredictsAlt,description,stateNumber)
 */
{
<if(!semPredState)>
    int LA<decisionNumber>_<stateNumber> = LA(<k>);
<endif>
    <edges; separator="\nelse ">
    else 
    {
<if(eotPredictsAlt)>
        alt<decisionNumber>=<eotPredictsAlt>;
<else>
        <ruleBacktrackFailure()>
    
        <newNVException()>    
        goto rule<ruleDescriptor.name>Ex;

<endif>
    }
}
>>

newNVException() ::= <<
/* newNVException()
 */
exConstruct();
theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
theException()->message      = "<description>";
theException()->decisionNum  = <decisionNumber>;
theException()->state        = <stateNumber>;
<@noViableAltException()>
<\n>
>>

/** Same as a normal DFA state except that we don't examine lookahead
 *  for the bypass alternative.  It delays error detection but this
 *  is faster, smaller, and more what people expect.  For (X)? people
 *  expect "if ( LA(1)==X ) match(X);" and that's it.
 */
dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
/* dfaOptionalBlockState(k,edges,eotPredictsAlt,description,stateNumber,sempredState)
 */
{
    <if(!semPredState)>
    int LA<decisionNumber>_<stateNumber> = LA(<k>);
    <endif>
    <edges; separator="\nelse ">
}
>>

/** A DFA state that is actually the loopback decision of a closure
 *  loop.  If end-of-token (EOT) predicts any of the targets then it
 *  should act like a default clause (i.e., no error can be generated).
 *  This is used only in the lexer so that for ('a')* on the end of a rule
 *  anything other than 'a' predicts exiting.
 */

dfaLoopbackStateDecls()::= <<
/* dfaLoopbackStateDecls(decisionNumber)
 */
ANTLR3_UINT32   LA<decisionNumber>_<stateNumber>;
>>
dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
{
   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
    */
    <if(!semPredState)>
    int LA<decisionNumber>_<stateNumber> = LA(<k>);
    <endif>
    <edges; separator="\nelse "><\n>
    <if(eotPredictsAlt)>
    else 
    {
	alt<decisionNumber>=<eotPredictsAlt>;
    }<\n>
    <endif>
}
>>

/** An accept state indicates a unique alternative has been predicted */
dfaAcceptState(alt) ::= "alt<decisionNumber>=<alt>; /* dfaAcceptState(alt) */"

/** A simple edge with an expression.  If the expression is satisfied,
 *  enter to the target state.  To handle gated productions, we may
 *  have to evaluate some predicates for this edge.
 */
dfaEdge(labelExpr, targetState, predicates) ::= <<
/* dfaEdge(labelExpr, targetState, predicates)
 */
if ( (<labelExpr>) <if(predicates)>&& (<predicates>)<endif>) 
{
    <targetState>
}
>>

// F i x e d  D F A  (switch case)

/** A DFA state where a SWITCH may be generated.  The code generator
 *  decides if this is possible: CodeGenerator.canGenerateSwitch().
 */
dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
/* dfaStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
 */
switch ( LA(<k>) ) 
{
<edges; separator="\n">

default:
<if(eotPredictsAlt)>
    alt<decisionNumber>=<eotPredictsAlt>;
<else>
    <ruleBacktrackFailure()>
    <newNVException()>
    goto rule<ruleDescriptor.name>Ex;<\n>
<endif>
}<\n>
>>

dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
/* dfaOptionalBlockStateSwitch(k,edges,eotPredictsAlt,description,stateNumber)
 */
switch ( LA(<k>) ) 
{
    <edges; separator="\n">
}<\n>
>>

dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState) ::= <<
/* dfaLoopbackStateSwitch(k, edges,eotPredictsAlt,description,stateNumber,semPredState)
 */
switch ( LA(<k>) ) 
{
<edges; separator="\n"><\n>
<if(eotPredictsAlt)>
default:
    alt<decisionNumber>=<eotPredictsAlt>;
    break;<\n>
<endif>
}<\n>
>>

dfaEdgeSwitch(labels, targetState) ::= <<
/* dfaEdgeSwitch(labels, targetState)
 */
<labels:{case <it>:}; separator="\n">
    <targetState>
    break;
>>

// C y c l i c  D F A

/** The code to initiate execution of a cyclic DFA; this is used
 *  in the rule to predict an alt just like the fixed DFA case.
 *  The <name> attribute is inherited via the parser, lexer, ...
 */
dfaDecision(decisionNumber,description) ::= <<
/* dfaDecision(decisionNumber,description)
 */
alt<decisionNumber> = cdfa<decisionNumber>.predict(ctx, rec, theInput()->istream, &cdfa<decisionNumber>);
>>

/* Dump DFA tables as static initialized arrays of shorts(16 bits)/characters(8 bits)
 * which are then used to statically initialize the dfa structure, which means that there
 * is no runtime initialization whatsoever, other than anything the C compiler might
 * need to generate. In general the C compiler will lay out memory such that there is no 
 * runtime code required.
 */
cyclicDFA(dfa) ::= <<
/** Static dfa state tables for Cyclic dfa:
 *    <dfa.description>
 */
static const ANTLR3_INT16 dfa<dfa.decisionNumber>_eot[<dfa.numberOfStates>] =
    {
	<dfa.eot; wrap="\n", separator=", ", null="-1">
    };
static const ANTLR3_INT16 dfa<dfa.decisionNumber>_eof[<dfa.numberOfStates>] =
    {
	<dfa.eof; wrap="\n", separator=", ", null="-1">
    };
static const ANTLR3_INT16 dfa<dfa.decisionNumber>_min[<dfa.numberOfStates>] =
    {
	<dfa.min; wrap="\n", separator=", ", null="-1">
    };
static const ANTLR3_INT16 dfa<dfa.decisionNumber>_max[<dfa.numberOfStates>] =
    {
	<dfa.max; wrap="\n", separator=", ", null="-1">
    };
static const ANTLR3_INT16 dfa<dfa.decisionNumber>_accept[<dfa.numberOfStates>] =
    {
	<dfa.accept; wrap="\n", separator=", ", null="-1">
    };
static const ANTLR3_INT16 dfa<dfa.decisionNumber>_special[<dfa.numberOfStates>] =
    {	
	<dfa.special; wrap="\n", separator=", ", null="-1">
    };

/** Used when there is no transition table entry for a particular state */
#define dfa<dfa.decisionNumber>_T_empty	    NULL

<dfa.edgeTransitionClassMap.keys:{ table |
static const ANTLR3_INT16 dfa<dfa.decisionNumber>_T<i0>[] =
    {
	<table; separator=", ", wrap="\n", null="-1">
    };}; null = "">

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT16 * const dfa<dfa.decisionNumber>_transitions[] =
{
    <dfa.transitionEdgeTables:{xref|dfa<dfa.decisionNumber>_T<xref>}; separator=", ", wrap="\n", null="_empty">	
};

<if(dfa.specialStateSTs)>
static ANTLR3_INT16 dfa<dfa.decisionNumber>_sst(p<name> ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_UINT32 s)
{
    ANTLR3_INT16    _s;
    
    _s	    = s;
    switch  (s)
    {
    <dfa.specialStateSTs:{state |
    case <i0>:
    
	<state>}; separator="\n">
    }
<if(backtracking)>
    if (backtracking > 0)
    {
	failedFlag = ANTLR3_TRUE;
	return	-1;
    }
<endif>
    
    exConstruct();
    theException()->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    theException()->message      = "<dfa.description>";
    theException()->decisionNum  = <dfa.decisionNumber>;
    theException()->state        = _s;
    <@noViableAltException()>
    return -1;
}
<endif>

<@errorMethod()>

/* Declare tracking structure for Cyclic DFA <dfa.decisionNumber>
 */
ANTLR3_CYCLIC_DFA cdfa<dfa.decisionNumber>
    =	{
	    <dfa.decisionNumber>,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"<dfa.description>",	
<if(dfa.specialStateSTs)>
	    (CDFA_SPECIAL_FUNC) dfa<dfa.decisionNumber>_sst,
<else>
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/
<endif>

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa<dfa.decisionNumber>_eot,	    /* EOT table			    */
	    dfa<dfa.decisionNumber>_eof,	    /* EOF table			    */
	    dfa<dfa.decisionNumber>_min,	    /* Minimum tokens for each state    */
	    dfa<dfa.decisionNumber>_max,	    /* Maximum tokens for each state    */
	    dfa<dfa.decisionNumber>_accept,	/* Accept table			    */
	    dfa<dfa.decisionNumber>_special,	/* Special transition states	    */
	    dfa<dfa.decisionNumber>_transitions	/* Table of transition tables	    */

	};	    
/* End of Cyclic DFA <dfa.decisionNumber>
 * ---------------------
 */
>>

/** A state in a cyclic DFA; it's a special state and part of a big switch on
 *  state.
 */
cyclicDFAState(decisionNumber,stateNumber,edges,needErrorClause,semPredState) ::= <<
{
    <if(semPredState)>
    rewindLast();<\n>
    <else>
    int LA<decisionNumber>_<stateNumber> = LA(1);<\n>
    <endif>
    s = -1;
    <edges; separator="\nelse ">
    if ( s>=0 ) 
    {
	return s;
    }
}
break;
>>

/** Just like a fixed DFA edge, test the lookahead and indicate what
 *  state to jump to next if successful.
 */
cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates) ::= <<
/* cyclicDFAEdge(labelExpr, targetStateNumber, edgeNumber, predicates)
 */
if ( <labelExpr> <if(predicates)>&& <predicates><endif>)
{
    s = <targetStateNumber>;
}<\n>
>>

/** An edge pointing at end-of-token; essentially matches any char;
 *  always jump to the target.
 */
eotDFAEdge(targetStateNumber,edgeNumber, predicates) ::= <<
 s = <targetStateNumber>;<\n>
>>


// D F A  E X P R E S S I O N S

andPredicates(left,right) ::= "( <left> && <right> )"

orPredicates(operands) ::= "(<first(operands)><rest(operands):{o | ||<o>}>)"

notPredicate(pred) ::= "!( <evalPredicate(...)> )"

evalPredicate(pred,description) ::= "<pred>"

evalSynPredicate(pred,description) ::= "<pred>(ctx)"

lookaheadTest(atom,k,atomAsInt) ::= "LA<decisionNumber>_<stateNumber> == <atom>"

/** Sometimes a lookahead test cannot assume that LA(k) is in a temp variable
 *  somewhere.  Must ask for the lookahead directly.
 */
isolatedLookaheadTest(atom,k,atomAsInt) ::= "LA(<k>) == <atom>"

lookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= <<
(LA<decisionNumber>_<stateNumber> \>= <lower> && LA<decisionNumber>_<stateNumber> \<= <upper>)
>>

isolatedLookaheadRangeTest(lower,upper,k,rangeNumber,lowerAsInt,upperAsInt) ::= "(LA(<k>) \>= <lower> && LA(<k>) \<= <upper>)"

setTest(ranges) ::= "<ranges; separator=\" || \">"

// A T T R I B U T E S

makeScopeSet() ::= <<
/* makeScopeSet() 
 */
 /** Definition of the <scope.name> scope variable tracking
 *  structure. An instance of this structure is created by calling
 *  <name>_<scope.name>Push().
 */
typedef struct  <scopeStruct(sname=scope.name,...)>_struct
{
    /** Function that the user may provide to be called when the
     *  scope is destroyed (so you can free pANTLR3_HASH_TABLES and so on)
     *
     * \param POinter to an instance of this typedef/struct
     */
    void    (*free)	(struct <scopeStruct(sname=scope.name,...)>_struct * frame);
    
    /* =============================================================================
     * Programmer defined variables...
     */
    <scope.attributes:{<it.decl>;}; separator="\n">

    /* End of programmer defined variables
     * =============================================================================
     */
} 
    <scopeStruct(sname=scope.name,...)>, * <scopeType(sname=scope.name,...)>;

>>

globalAttributeScopeDecl(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScopeDecl(scope)
 */
<makeScopeSet(...)>
<endif>
>>

ruleAttributeScopeDecl(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeDecl(scope)
 */
<makeScopeSet(...)>
<endif>
>>

globalAttributeScopeFuncDecl(scope) ::= 
<<
/* globalAttributeScopeFuncDecl(scope)
 */
<if(scope.attributes)>
/* -----------------------------------------------------------------------------
 * Function declaration for creating a <name>_<scope.name> scope set 
 */
static <scopeType(sname=scope.name,...)>   <scopePushName(sname=scope.name,...)>(p<name> ctx);
/* ----------------------------------------------------------------------------- */

<endif>
>>

globalAttributeScopeFuncMacro(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScopeFuncMacro(scope)
 */
/** Macro for popping the top value from a <scopeStack(sname=scope.name)>
 */
#define <scopePopName(sname=scope.name,...)>()  ctx-><scopeStack(sname=scope.name,...)>->pop(ctx-><scopeStack(sname=scope.name,...)>)

<endif>
>>

ruleAttributeScopeFuncDecl(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a <name>_<scope.name> scope set 
 */
static <scopeType(sname=scope.name,...)>   <scopePushName(sname=scope.name,...)>(p<name> ctx);
/* ----------------------------------------------------------------------------- */

<endif>
>>

ruleAttributeScopeFuncMacro(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeFuncMacro(scope)
 */
/** Macro for popping the top value from a <scopeStack(sname=scope.name,...)>
 */
#define <scopePopName(sname=scope.name,...)>()  ctx-><scopeStack(sname=scope.name,...)>->pop(ctx-><scopeStack(sname=scope.name)>)

<endif>
>>
globalAttributeScopeDef(scope) ::= 
<<
/* globalAttributeScopeDef(scope)
 */
<if(scope.attributes)>
/** Pointer to the  <scope.name> stack for use by <scopePushName(sname=scope.name)>()
 *  and <scopePopName(sname=scope.name,...)>()
 */
pANTLR3_STACK <scopeStack(sname=scope.name)>;
/** Pointer to the top of the stack for the global scope <scopeStack(sname=scope.name)>
 */
<scopeType(sname=scope.name,...)>    <scopeTopDecl(sname=scope.name,...)>;
<scopeType(sname=scope.name,...)>    <scopePushName(sname=scope.name,...)>(struct <name>_Ctx_struct * ctx);

<endif>
>>

ruleAttributeScopeDef(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeDef(scope)
 */
/** Pointer to the  <scope.name> stack for use by <scopePushName(sname=scope.name)>()
 *  and <scopePopName(sname=scope.name,...)>()
 */
pANTLR3_STACK <scopeStack(sname=scope.name,...)>;
<scopeType(sname=scope.name,...)>   (*<scopePushName(sname=scope.name,...)>)(struct <name>_Ctx_struct * ctx);
<scopeType(sname=scope.name,...)>   <scopeTopDecl(sname=scope.name,...)>;

<endif>
>>

globalAttributeScopeFuncs(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScopeFuncs(scope)
 */
<attributeFuncs(scope)>
<endif>
>>

ruleAttributeScopeFuncs(scope) ::= <<
<if(scope.attributes)>
/* ruleAttributeScopeFuncs(scope)
 */
<attributeFuncs(scope)>
<endif>
>>

globalAttributeScope(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScope(scope)  
 */
ctx-><scopePushName(sname=scope.name,...)>     = <scopePushName(sname=scope.name,...)>;
ctx-><scopeStack(sname=scope.name,...)>    = antlr3StackNew(ANTLR3_SIZE_HINT);
<scopeTop(sname=scope.name,...)>      = NULL;
<endif>
>>

ruleAttributeScope(scope) ::= 
<<
<if(scope.attributes)>
/* ruleAttributeScope(scope)
 */
ctx-><scopePushName(sname=scope.name,...)>     = <scopePushName(sname=scope.name,...)>;
ctx-><scopeStack(sname=scope.name,...)>    = antlr3StackNew(ANTLR3_SIZE_HINT);
<scopeTop(sname=scope.name,...)>      = NULL;
<endif>
>>
globalAttributeScopeFree(scope) ::= <<
<if(scope.attributes)>
/* globalAttributeScope(scope)  
 */
ctx-><scopeStack(sname=scope.name,...)>-\>free(ctx-><scopeStack(sname=scope.name,...)>);
<endif>
>>

ruleAttributeScopeFree(scope) ::= 
<<
<if(scope.attributes)>
/* ruleAttributeScope(scope)
 */
ctx-><scopeStack(sname=scope.name,...)>-\>free(ctx-><scopeStack(sname=scope.name,...)>);
<endif>
>>

scopeTopDecl(sname) ::= <<
p<name>_<sname>Top
>>

scopeTop(sname) ::= <<
ctx-><scopeTopDecl(sname=sname,...)>
>>

scopePop(sname) ::= <<
<scopePopName(sname=sname,...)>();
>>

scopePush(sname) ::= <<
p<name>_<sname>Push(ctx)
>>

scopePopName(sname) ::= <<
p<name>_<sname>Pop
>>

scopePushName(sname) ::= <<
p<name>_<sname>Push
>>

scopeType(sname) ::= <<
p<name>_<sname>_SCOPE
>>

scopeStruct(sname) ::= <<
<name>_<sname>_SCOPE
>>

scopeStack(sname) ::= <<
p<name>_<sname>Stack
>>

attributeFuncs(scope) ::= <<
<if(scope.attributes)>
/* attributeFuncs(scope)
 */

static void <scope.name>Free(void * data)
{
    ANTLR3_FREE(data);
}

/** \brief Allocate initial memory for a <name> <scope.name> scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code: 
 * \code 
 *   <scopeTop(sname=scope.name)>->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as: 
 * \code
 *   void myfunc( <scopeType(sname=scope.name)> ptr). 
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE, not free()
 * then free the entry it is given with: 
 * \code
 *   ANTLR3_FREE(ptr);
 * \endcode
 * 
 */ 
static <scopeType(sname=scope.name)>
<scopePushName(sname=scope.name)>(p<name> ctx)
{
    /* Pointer used to create a new set of attributes
     */
    <scopeType(sname=scope.name)>      newAttributes;

    /* Allocate the memory for a new structure
     */
    newAttributes = (<scopeType(sname=scope.name)>) ANTLR3_MALLOC(sizeof(<scopeStruct(sname=scope.name)>));

    if  (newAttributes != NULL)
    {
	/* Standard ANTLR3 library implementation
	 */
	ctx-><scopeStack(sname=scope.name)>->push(ctx-><scopeStack(sname=scope.name)>, newAttributes, <scope.name>Free);
	
	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
	 */
    }
 
    /* Calling routine will throw an exeception if this
     * fails and this pointer is NULL.
     */
    return  newAttributes;
}<\n>

<endif>
>>

returnType() ::= <<
<if(!ruleDescriptor.isSynPred)>
<if(ruleDescriptor.hasMultipleReturnValues)>
<name>_<ruleDescriptor.name>_return
<else>
<if(ruleDescriptor.hasSingleReturnValue)>
<ruleDescriptor.singleValueReturnType>
<else>
void
<endif>
<endif>
<else>
ANTLR3_BOOLEAN
<endif>
>>

/** Generate the Java type associated with a single or multiple return
 *  values.
 */
ruleLabelType(referencedRule) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
<name>_<referencedRule.name>_return
<else>
<if(referencedRule.hasSingleReturnValue)>
<referencedRule.singleValueReturnType>
<else>
void
<endif>
<endif>
>>

/** Using a type to init value map, try to init a type; if not in table
 *  must be an object, default value is "0".
 */
initValue(typeName) ::= <<
<cTypeInitMap.(typeName)>
>>

/** Define a rule label  */
ruleLabelDef(label) ::= <<
<ruleLabelType(referencedRule=label.referencedRule)> <label.label.text>;
#undef	RETURN_TYPE_<label.label.text>
#define	RETURN_TYPE_<label.label.text> <ruleLabelType(referencedRule=label.referencedRule)><\n>
>>
/**  a rule label including default value */
ruleLabelInitVal(label) ::= <<
>>

/** Define a return struct for a rule if the code needs to access its
 *  start/stop tokens, tree stuff, attributes, ...  Leave a hole for
 *  subgroups to stick in members.
 */
returnScope() ::= <<
<if(!ruleDescriptor.isSynPred)>
<if(ruleDescriptor.hasMultipleReturnValues)>
typedef struct <returnType(...)>_struct
{
    /** Generic return elements for ANTLR3 rules
     */
    <@ruleReturnMembers()>   
    <ruleDescriptor.returnScope.attributes:{<it.decl>;}; separator="\n">
}
    <returnType(...)>;<\n><\n>
<endif>
<endif>
>>

parameterScope(scope) ::= <<
<scope.attributes:{<it.decl>}; separator=", ">
>>

/** Used in codegen.g to translate $x.y references.
 *  I could have left actions as StringTemplates to be inserted in
 *  the output (so they could use attributes inherited from surrounding
 *  templates), but really wanted to pass in AttributeScope and Attribute
 *  objects so this translation could query them.  So, translation of
 *  $x.y to executable code occurs before recognizerST.toString() occurs.
 *  I.e., actions are just text strings during final code generation.
globalAttributeRef(scope,attr) ::= <<
(ctx-><scopeTop(sname=scope,...)>)-><attr.name>
>>
 */

parameterAttributeRef(attr) ::= "<attr.name>"
parameterSetAttributeRef(attr,expr) ::= "<attr.name> = <expr>;"

/** Note that the scopeAttributeRef does not have access to the
 * grammar name directly
 */
scopeAttributeRef(scope,attr,index,negIndex) ::= <<
<if(negIndex)>
((SCOPE_TYPE(scope))ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope), ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope))-<negIndex>-1)-><attr.name>
<else>
<if(index)>
((SCOPE_TYPE(scope))ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope), (ANTLR3_UINT64)<index>))-><attr.name>
<else>
SCOPE_TOP(<scope>)-><attr.name>
<endif>
<endif>
>>

scopeSetAttributeRef(scope,attr,expr,index,negIndex) ::= <<
<if(negIndex)>
((SCOPE_TYPE(scope))ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope), ctx->SCOPE_STACK(scope)->size(ctx->SCOPE_STACK(scope))-<negIndex>-1)-><attr.name> = <expr>;
<else>
<if(index)>
((SCOPE_TYPE(scope))ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope), (ANTLR3_UINT64)<index>))-><attr.name> = <expr>;
<else>
SCOPE_TOP(<scope>)-><attr.name> = <expr>;
<endif>
<endif>
>>

/** $x is either global scope or x is rule with dynamic scope; refers
 *  to stack itself not top of stack.  This is useful for predicates
 *  like {$function.size()>0 && $function::name.equals("foo")}?
 */
isolatedDynamicScopeRef(scope) ::= "<scope>_stack"

/** reference an attribute of rule; might only have single return value */
ruleLabelRef(referencedRule,scope,attr) ::= <<
<if(referencedRule.hasMultipleReturnValues)>
<scope>.<attr.name>
<else>
<scope>
<endif>
>>

returnAttributeRef(ruleDescriptor,attr) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name>
<else>
<attr.name>
<endif>
>>

returnSetAttributeRef(ruleDescriptor,attr,expr) ::= <<
<if(ruleDescriptor.hasMultipleReturnValues)>
retval.<attr.name> = <expr>;
<else>
<attr.name> = <expr>;
<endif>
>>

/** How to translate $tokenLabel */
tokenLabelRef(label) ::= "<label>"

/** ids+=ID {$ids} or e+=expr {$e} */
listLabelRef(label) ::= "list_<label>"


// not sure the next are the right approach; and they are evaluated early;
// they cannot see TREE_PARSER or PARSER attributes for example. :(

tokenLabelPropertyRef_text(scope,attr) ::= "<scope>->getText(<scope>)"
tokenLabelPropertyRef_type(scope,attr) ::= "<scope>->getType(<scope>)"
tokenLabelPropertyRef_line(scope,attr) ::= "<scope>->getLine(<scope>)"
tokenLabelPropertyRef_pos(scope,attr) ::= "<scope>->getCharPositionInLine(<scope>)"
tokenLabelPropertyRef_channel(scope,attr) ::= "<scope>->getChannel(<scope>)"
tokenLabelPropertyRef_index(scope,attr) ::= "<scope>->getTokenIndex(<scope>)"
tokenLabelPropertyRef_tree(scope,attr) ::= "<scope>->tree"

ruleLabelPropertyRef_start(scope,attr) ::= "((<labelType>)<scope>.start)"
ruleLabelPropertyRef_stop(scope,attr) ::= "((<labelType>)<scope>.stop)"
ruleLabelPropertyRef_tree(scope,attr) ::= "((<ASTLabelType>)<scope>.tree)"
ruleLabelPropertyRef_text(scope,attr) ::= "strStream->toString(<scope>.start,<scope>.stop)"
ruleLabelPropertyRef_st(scope,attr) ::= "<scope>.st"

/** Isolated $RULE ref ok in lexer as it's a Token */
lexerRuleLabel(label) ::= "<label>"

lexerRuleLabelPropertyRef_type(scope,attr) ::= "<scope>->getType(<scope>)"
lexerRuleLabelPropertyRef_line(scope,attr) ::= "<scope>->getLine(<scope>)"
lexerRuleLabelPropertyRef_pos(scope,attr) ::= "<scope>->getCharPositionInLine(<scope>)"
lexerRuleLabelPropertyRef_channel(scope,attr) ::= "<scope>->getChannel(<scope>)"
lexerRuleLabelPropertyRef_index(scope,attr) ::= "<scope>->getTokenIndex(<scope>)"
lexerRuleLabelPropertyRef_text(scope,attr) ::= "<scope>->getText(<scope>)"

// Somebody may ref $template or $tree or $stop within a rule:
rulePropertyRef_start(scope,attr) ::= "((<labelType>)retval).start"
rulePropertyRef_stop(scope,attr) ::= "((<labelType>)retval).stop"
rulePropertyRef_tree(scope,attr) ::= "((<labelType>)retval).tree"
rulePropertyRef_text(scope,attr) ::= "strStream->toString(retval.start,LT(-1))"
rulePropertyRef_st(scope,attr) ::= "retval.st"

// setting $st and $tree is allowed in local rule. everything else is flagged as error
ruleSetPropertyRef_tree(scope,attr,expr) ::= "((<labelType>)retval).tree = <expr>;"
ruleSetPropertyRef_st(scope,attr,expr) ::= "retval.st = <expr>;"


/** How to execute an action */
execAction(action) ::= <<
/* execAction(action)
 */
<if(backtracking)>
<if(actions.(actionScope).synpredgate)>
if ( <actions.(actionScope).synpredgate> ) 
{
    <action>
}
<else>
if ( backtracking == 0 ) 
{
    <action>
}
<endif>
<else>
{
    <action>
}
<endif>
>>

// M I S C (properties, etc...)

bitsetDeclare(name, words64) ::= <<

/**
 * Bitset defining follow set for error recovery in
 * rule state: <name>
 */
static  pANTLR3_BITSET <name>;
static  ANTLR3_UINT64 <name>_bits[] = { <words64:{ANTLR3_UINT64_LIT(<it>)}; separator=", "> };
>>

bitset(name, words64) ::= <<
/* bitset(name, words64)
 */
<name> = antlr3BitsetLoad((sizeof(<name>_bits)/sizeof(ANTLR3_UINT64)), <name>_bits);<\n>
>>

bitsetFree(name) ::= <<
<name>-\>free(<name>);<\n>
>>


codeFileExtension() ::= ".c"

true() ::= "ANTLR3_TRUE"
false() ::= "ANTLR3_FALSE"
